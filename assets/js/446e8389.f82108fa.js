"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2755],{58387:e=>{e.exports=JSON.parse('{"functions":[{"name":"Start","desc":"Starts Framework on the server. It will return a `Promise`. You can call start multiple times\\nbut it is recommended that you have it called from one script only.\\n```lua\\n    local Framework = :Import(\\"Framework\\");\\n    Framework:Start():Then(function(lib)\\n        print(\\"Framework is running on the server\\");\\n    end):Catch(function(err)\\n        warn(\\"Framework failed to start on the server because \\",err)\\n    end);\\n```","params":[],"returns":[],"function_type":"method","source":{"line":76,"path":"src/Core/Libraries/Framework/FrameworkServer/init.lua"}},{"name":"PortComponentClasses","desc":"Allows you to port multiple component classes at once.","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":139,"path":"src/Core/Libraries/Framework/FrameworkServer/init.lua"}},{"name":"PortComponentClass","desc":"ComponentClass are just modules which you can access by using Framework:GetComponentClass()\\n\\nFor example, let\'s say in one of our services, we want to create a custom class. Instead of having the custom \\nclass code in the service, we can port it as a component class. This is just a shorter version of having your\\ncomponents stored somewhere in replicated storage/server storage and having to load them.\\n\\nSo basically, instead of having to use `game:GetService(\\"ReplicatedStorage\\"):WaitForChild(\\"Components\\"):WaitForChild(\\"Component\\")`;\\nYou would just port your entire Component folder, then access them using `:GetComponentClass`","params":[{"name":"Component","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":159,"path":"src/Core/Libraries/Framework/FrameworkServer/init.lua"}},{"name":"PortServices","desc":"Allows you to port multiple services at once","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":167,"path":"src/Core/Libraries/Framework/FrameworkServer/init.lua"}},{"name":"PortService","desc":"Before Framework starts, you should call this method.\\n\\nYou are expected to pass a folder, every module in that folder will be converted into Services then destroyed.\\n\\nServices need two methods, Init and Start\\n\\n## Services Lifecycle\\n\\n:::note\\nWhenever PortServices is called, it will loop through each Service and call their :Init method. After all\\nServices are Initiated, It will then call the :Start method for each Service. So within the :Start method that means\\nevery Service was created and initiated, hence you can use :GetService() to get other Services within a Service.\\n:::\\n\\nExample Service 1:\\n```lua\\nlocal MyService = {\\n    initiated = false --\x3e example property\\n};\\n\\nfunction MyService:Init()\\n    print(self.Name..\\" is being initiated\\"); --\x3e \\"MyService is being initiated\\";\\n    self.initiated = true;\\n    print(self.Name..\\" was initiated\\");\\nend;\\n\\nfunction MyService:Start()\\n    print(self.Name..\\" has started\\"); --\x3e \\"MyService has started\\";\\nend;\\n\\nreturn MyService;\\n```\\nExample Service 2:\\n```lua\\nlocal MyService2 = {}\\n\\nfunction MyService2:Init()\\n    print(self.Name..\\" is being initiated\\"); --\x3e \\"MyService2 is being initiated\\" !! Will print along side \\"MyService is being ititiated\\"\\nend;\\n\\nfunction MyService2:Start()\\n    local MyService = self:GetService(\\"MyService\\");\\n    print(MyService.initiated) --\x3e true\\nend;\\n\\nreturn MyService;\\n```\\n\\n:::warning\\nThere\'s no order in which services are initiated, this means trying to access another service within your Service\\n:Init lifecycle can throw an error or infinite yield\\n:::","params":[{"name":"Service","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":232,"path":"src/Core/Libraries/Framework/FrameworkServer/init.lua"}},{"name":"GetService","desc":"    ","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","tags":["FrameworkService"],"source":{"line":262,"path":"src/Core/Libraries/Framework/FrameworkServer/init.lua"}},{"name":"GetComponentClass","desc":"    ","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","tags":["FrameworkService"],"source":{"line":270,"path":"src/Core/Libraries/Framework/FrameworkServer/init.lua"}},{"name":"UseChannel","desc":":::warning\\nIn Order for this to work the service must have a `Shared` property.\\n:::\\n\\nIdealy, you would want to call this method during the services Init lifecycle. You will then be able to access\\nthis Channel on the client by using `Service:UseChannel(ChannelName)`\\n\\nChannels are just [RemoteEvent]\'s.\\n    ","params":[{"name":"ChannelName","desc":"","lua_type":"string"},{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"RemoteEvent\\n"}],"function_type":"method","tags":["FrameworkService"],"source":{"line":286,"path":"src/Core/Libraries/Framework/FrameworkServer/init.lua"}},{"name":"GetService","desc":"","params":[{"name":"ServiceName","desc":"","lua_type":"string"}],"returns":[],"function_type":"method","source":{"line":358,"path":"src/Core/Libraries/Framework/FrameworkServer/init.lua"}},{"name":"GetComponentClass","desc":"","params":[{"name":"ClassName","desc":"","lua_type":"string"}],"returns":[],"function_type":"method","source":{"line":366,"path":"src/Core/Libraries/Framework/FrameworkServer/init.lua"}},{"name":"GetService","desc":"    ","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","tags":["FrameworkService"],"source":{"line":347,"path":"src/Core/Libraries/Framework/FrameworkBranch.lua"}},{"name":"GetBranch","desc":"    ","params":[{"name":"Branch","desc":"","lua_type":"string"}],"returns":[],"function_type":"method","tags":["FrameworkService"],"source":{"line":354,"path":"src/Core/Libraries/Framework/FrameworkBranch.lua"}},{"name":"GetComponentClass","desc":"    ","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","tags":["FrameworkService"],"source":{"line":366,"path":"src/Core/Libraries/Framework/FrameworkBranch.lua"}},{"name":"UseChannel","desc":":::warning\\nIn Order for this to work the service must have a `Shared` property.\\n:::\\n\\nIdealy, you would want to call this method during the services Init lifecycle. You will then be able to access\\nthis Channel on the client by using `Service:UseChannel(ChannelName)`\\n\\nChannels are just [RemoteEvent]\'s.\\n    ","params":[{"name":"ChannelName","desc":"","lua_type":"string"},{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"RemoteEvent\\n"}],"function_type":"method","tags":["FrameworkService"],"source":{"line":382,"path":"src/Core/Libraries/Framework/FrameworkBranch.lua"}}],"properties":[{"name":"Shared","desc":"To create a Service that can be accessed by the client, you need to creat a `Shared` property. Leave as `nil` if you want to create a ServerSided Service.","lua_type":"table","realm":["Server"],"source":{"line":58,"path":"src/Core/Libraries/Framework/FrameworkServer/init.lua"}}],"types":[],"name":"FrameworkServer","desc":"Use `PowerHorseEngine:Import(\\"Framework\\")` from a server script to access this library.\\n\\n:::warning\\nAnything on this page tagged with `FrameworkService` refers to the [Pseudo] service that is created after porting the service module!\\nThese functions/properties are not accessible from this library itself\\n\\ne.g\\n```lua\\nFrameworkService:PortService() --\x3e Will work.\\nFrameworkService:UseChannel() --\x3e Will not work.\\n```\\n:::","realm":["Server"],"source":{"line":50,"path":"src/Core/Libraries/Framework/FrameworkServer/init.lua"}}')}}]);