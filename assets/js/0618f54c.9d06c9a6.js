"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1372],{99399:e=>{e.exports=JSON.parse('{"functions":[{"name":"Start","desc":"Starts Framework on the client. It will return a `Promise`. You can call start multiple times\\nbut it is recommended that you have it called from one script only.\\n```lua\\n    local Framework = :Import(\\"Framework\\");\\n    Framework:Start():Then(function(lib)\\n        print(\\"Framework is running on the client\\");\\n    end):Catch(function(err)\\n        warn(\\"Framework failed to start on the client because \\",err)\\n    end);\\n```","params":[],"returns":[],"function_type":"method","source":{"line":33,"path":"src/Core/Libraries/Framework/FrameworkClient/init.lua"}},{"name":"PortComponentClasses","desc":"Allows you to port multiple component classes at once.","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":74,"path":"src/Core/Libraries/Framework/FrameworkClient/init.lua"}},{"name":"PortComponentClass","desc":"ComponentClass are just modules which you can access by using Framework:GetComponentClass()\\n\\nFor example, let\'s say in one of our services, we want to create a custom class. Instead of having the custom \\nclass code in the service, we can port it as a component class. This is just a shorter version of having your\\ncomponents stored somewhere in replicated storage/server storage and having to load them.\\n\\nSo basically, instead of having to use `game:GetService(\\"ReplicatedStorage\\"):WaitForChild(\\"Components\\"):WaitForChild(\\"Component\\")`;\\nYou would just port your entire Component folder, then access them using `:GetComponentClass`","params":[{"name":"Component","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":94,"path":"src/Core/Libraries/Framework/FrameworkClient/init.lua"}},{"name":"PortModulars","desc":"Allows you to port multiple modulars at once\\n:PortModulars(BasicModularsPath,AdvancedModularsPath,BackupModularsPath)","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":104,"path":"src/Core/Libraries/Framework/FrameworkClient/init.lua"}},{"name":"PortModular","desc":"Before Framework starts, you should call this method.\\nA modular is considered the client version of a service.\\n\\nYou are expected to pass a folder, every module in that folder will be converted into modulars then destroyed.\\n\\nModulars need two methods, Init and Start\\n\\n## Modulars Lifecycle\\n\\n:::note\\nWhenever PortModulars is called, it will loop through each modular and call their :Init method. After all\\nModulars are Initiated, It will then call the :Start method for each modular. So within the :Start method that means\\nevery modular was created and initiated, hence you can use :GetModular() to get other modulars within a modular.\\n:::\\n\\nExample Modular 1:\\n```lua\\nlocal MyModular = {\\n    initiated = false --\x3e example property\\n};\\n\\nfunction MyModular:Init()\\n    print(self.Name..\\" is being initiated\\"); --\x3e \\"MyModular is being initiated\\";\\n    self.initiated = true;\\n    print(self.Name..\\" was initiated\\");\\nend;\\n\\nfunction MyModular:Start()\\n    print(self.Name..\\" has started\\"); --\x3e \\"MyModular has started\\";\\nend;\\n\\nreturn MyModular;\\n```\\nExample Modular 2:\\n```lua\\nlocal MyModular2 = {}\\n\\nfunction MyModular2:Init()\\n    print(self.Name..\\" is being initiated\\"); --\x3e \\"MyModular2 is being initiated\\" !! Will print along side \\"MyModular is being ititiated\\"\\nend;\\n\\nfunction MyModular2:Start()\\n    local MyModular = self:GetModular(\\"MyModular\\");\\n    print(MyModular.initiated) --\x3e true\\nend;\\n\\nreturn MyModular;\\n```\\n\\n:::warning\\nThere\'s no order in which modulars are initiated, this means trying to access another modular within your modulars\\n:Init lifecycle can throw an error or infinite yield\\n:::\\n\\n\\n\\n:::note\\nYou can access server modulars which are actually just called \\"Services\\" within your modulars by using\\n:GetService. The services must have a shared property though, learn more about here from `FrameworkServer` \\n:::","params":[{"name":"Modular","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":176,"path":"src/Core/Libraries/Framework/FrameworkClient/init.lua"}},{"name":"GetModular","desc":"","params":[{"name":"ServiceName","desc":"","lua_type":"string"}],"returns":[],"function_type":"method","source":{"line":245,"path":"src/Core/Libraries/Framework/FrameworkClient/init.lua"}},{"name":"GetService","desc":":::note\\nUsed to access server Services\\n\\nOnce the Service provides a shared prop, It will wait until the Service was initiated on the server.\\nSo calling Framework:GetService before Frame:Start was called is fine and will yield until the server \\ninitiated the service. You are not required to use `Modulars` to access `Services`\\n:::","params":[{"name":"ServiceName","desc":"","lua_type":"string"}],"returns":[],"function_type":"method","source":{"line":263,"path":"src/Core/Libraries/Framework/FrameworkClient/init.lua"}},{"name":"GetComponentClass","desc":"","params":[{"name":"ClassName","desc":"","lua_type":"string"}],"returns":[],"function_type":"method","source":{"line":323,"path":"src/Core/Libraries/Framework/FrameworkClient/init.lua"}}],"properties":[],"types":[],"name":"FrameworkClient","desc":"Use `PowerHorseEngine:Import(\\"Framework\\")` from a client script to access this library.","realm":["Client"],"source":{"line":15,"path":"src/Core/Libraries/Framework/FrameworkClient/init.lua"}}')}}]);