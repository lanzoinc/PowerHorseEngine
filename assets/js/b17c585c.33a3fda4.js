"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7419],{22586:e=>{e.exports=JSON.parse('{"functions":[{"name":"CreateClassAsync","desc":"Creates a custom class","params":[{"name":"ClassData","desc":"","lua_type":"table"},{"name":"Parent","desc":"","lua_type":"any"},{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"CustomClass"}],"function_type":"method","source":{"line":210,"path":"src/Core/Services/CustomClassService.lua"}},{"name":"Create","desc":"Alias for :CreateClassAsync","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"CustomClass"}],"function_type":"method","source":{"line":218,"path":"src/Core/Services/CustomClassService.lua"}}],"properties":[],"types":[],"name":"CustomClassService","desc":"`CustomClassService` is a way to create custom Pseudo elements into your projects.\\n\\n:::warning\\nCustomClasses will not replicate, They are completely bounded to their environment. After creating a custom class\\nit cannot be constructed with .new\\n:::\\n\\n:::warning\\nCustomClasses require a `.ClassName` property and a `:_Render` method. more about this is included in the example below\\n:::\\n\\nLet\'s create a class that is responsible for teleporting players during rounds\\n\\n```lua\\n\\tlocal TeleportClass = {\\n\\t\\tName = \\"TeleportClass\\", --\x3e Optional\\n\\t\\tClassName = \\"TeleportClass\\", --\x3e Required (Cannot be an existing built in ClassName)\\n\\t\\tOtherProperty = \\"string\\",\\n\\t\\tTextColor3 = Color3.new()\\n\\t};\\n\\n\\t--//Required\\n\\tfunction TeleportClass:_Render()\\n\\t\\t--//Before we continue, let\'s understand the :_Render Method\\n\\tend;\\n```\\n\\n## :_Render\\n\\nWhenever a class is in the process of being created, the `:_Render` method will be called upon. This method\\nwill only be called `once` in the classes lifecycle. The class expects the :_Render function to return some sort of value\\nto understand how the component should be rendered.\\n\\nThere are two types of rendering, Array Rendering and Functional Rendering\\n\\n### Array Rendering\\nWith array rendering, you return a dictionary within the :_Render function.\\n\\n```lua\\n\\tfunction TeleportClass:_Render()\\n\\t\\treturn {};\\n\\tend;\\n```\\nWithin that dictionary you can pass a string as a key which represents a property of the class and a value which is callback\\nfunction that will be called whenever that property is changed\\n\\n```lua\\n\\tfunction TeleportClass:_Render()\\n\\t\\t-- You would most likely create components here (this is called only once)\\n\\t\\tlocal TextLabel = Instance.new(\\"TextLabel\\");\\n\\t\\treturn {\\n\\t\\t\\t[\\"OtherProperty\\"] = function(newValue)\\n\\t\\t\\t\\t-- this is called everytime \\"OtherProperty\\" changed, you must likely would not create components here.\\n\\t\\t\\t\\tprint(\\"OtherPropertyChanged to : \\", newValue);\\n\\t\\t\\t\\tTextLabel.Text = newValue; -- this will now give the TextLabel a type of \\"Reactive\\" feel, since the text is now dynamically linked with our \\"OtherProperty\\" property.\\n\\t\\t\\tend;\\n\\t\\t};\\n\\tend;\\n```\\n\\nThere\'s also some keys that are reserved that have different functionalities\\n\\n#### _Components\\n\\nAnything listed here will be stored in the components _Components list, which you can then use :GET to retrieve\\n\\n```lua\\n\\tfunction TeleportClass:_Render()\\n\\t\\tlocal TextLabel = Instance.new(\\"TextLabel\\");\\n\\t\\treturn {\\n\\t\\t\\t[\\"OtherProperty\\"] = function(newValue)\\n\\t\\t\\t\\tprint(\\"OtherPropertyChanged to : \\", newValue);\\n\\t\\t\\t\\tTextLabel.Text = tostring(newValue);\\n\\t\\t\\tend;\\n\\t\\t\\t_Components = {\\n\\t\\t\\t\\tImportantTextLabel = TextLabel\\n\\t\\t\\t}\\n\\t\\t};\\n\\tend;\\n\\t--Elsewhere:\\n\\t\\tTeleportClassObject:GET(\\"ImportantTextLabel\\");\\n```\\n\\n#### _Mapping\\n\\nMapping is used to automatically link two properties with the same key and value type together.\\n\\n```lua\\n\\tfunction TeleportClass:_Render()\\n\\t\\tlocal TextLabel = Instance.new(\\"TextLabel\\");\\n\\t\\treturn {\\n\\t\\t\\t[\\"OtherProperty\\"] = function(newValue)\\n\\t\\t\\t\\tprint(\\"OtherPropertyChanged to : \\", newValue);\\n\\t\\t\\t\\tTextLabel.Text = tostring(newValue);\\n\\t\\t\\tend;\\n\\t\\t\\t_Components = {\\n\\t\\t\\t\\tImportantTextLabel = TextLabel\\n\\t\\t\\t}\\n\\t\\t\\t_Mapping = {\\n\\t\\t\\t\\t[TextLabel] = {\\n\\t\\t\\t\\t\\t\\"OtherProperty\\", -- this will not work because text labels do not have a property called \\"OtherProperty\\"\\n\\t\\t\\t\\t\\t\\"TextColor3\\", -- this will work because both the component and textlabel has a \\"TextColor3\\" which are Color3\'s\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\tend;\\n```\\n\\n### Functional Rendering\\n\\nWhen using functional rendering, you need to return a function instead of a dictionary within the :_Render Method\\n\\n\\n```lua\\n\\tfunction TeleportClass:_Render()\\n\\t\\treturn function ()\\n\\t\\t\\tprint(\\"This is called whenever any property of the component is changed\\");\\n\\t\\tend;\\n\\n\\tend;\\n```\\n\\nAll :_Render functions pass a argument of \\"App\\" being the PowerHorseEngine module which it was created from.\\nWith functional rendering, you now have access to a second argument which is passed \\"hooks\\"\\n\\nlearn more about functional rendering hooks `here`\\n\\nHere\'s a quick example of using the `useEffect` along side the `useState` hook. We highly recommending viewing the `documentation` on it\\nfor a better understanding\\n\\n\\n```lua\\n\\tfunction TeleportClass:_Render(App,hooks)\\n\\t\\tlocal useState = hooks.useState;\\n\\t\\tlocal useEffect = hooks.useEffect;\\n\\n\\t\\tlocal AwesomeState,setAwesomeState = useState(0);\\n\\n\\t\\tuseEffect(function()\\n\\t\\t\\tprint(\\"This is only called when the state is changed\\")\\n\\t\\tend,{AwesomeState});\\n\\n\\t\\tuseEffect(function()\\n\\t\\t\\tprint(\\"This is only called when \\\\\\"OtherProperty\\\\\\" and \\\\\\"TextColor3\\\\\\" are changed\\")\\n\\t\\tend,{\\"OtherProperty\\",\\"TextColor3\\"})\\n\\n\\t\\tuseEffect(function()\\n\\t\\t\\tlocal doCleanupOnPreviousLoop = false;\\n\\t\\t\\tfor i = 1,AwesomeState,1 do\\n\\t\\t\\t\\tif(doCleanupOnPreviousLoop)then break;end;\\n\\t\\t\\t\\tprint(\\"Running at index : \\",i);\\n\\t\\t\\t\\twait(1);\\n\\t\\t\\tend;\\n\\t\\t\\treturn function ()\\n\\t\\t\\t\\t--//This will cause the previous for loop if still running to end whenever this useEffect hook is called\\n\\t\\t\\t\\tdoCleanupOnPreviousLoop = true; \\n\\t\\t\\tend;\\n\\t\\t\\t\\n\\t\\tend,{AwesomeState})\\n\\n\\n\\t\\treturn function ()\\n\\t\\t\\tprint(\\"This is called whenever any property of the component is changed\\");\\n\\t\\tend;\\n\\n\\tend;\\n```\\n\\nGreat. Now that we understand the :_Render method, let\'s actually make the teleporting class\\n\\n```lua\\n\\t-- somewhere is a module script on the server\\n\\t-- this is a very very basic example just for you to understand. we recommend looking into the `framework` library which is similar to `Knit`.\\n\\nlocal TeleportClass = {\\n\\t\\tName = \\"TeleportClass\\",\\n\\t\\tClassName = \\"TeleportClass\\", \\n\\t\\tBannedFromTeleporting = {};\\n\\t};\\n\\tfunction TeleportClass:_Render()\\n\\t\\treturn {};\\n\\tend;\\n\\n\\tfunction TeleportClass:TeleportUser(Player)\\n\\t\\tif(self.BannedFromTeleporting[Player.UserId])then return end;\\n\\t\\tPlayer.Character.BlahBlahBlah = BlahBlahBlah;\\n\\tend;\\n\\nreturn CustomClassService:CreateClassAsync(TeleportClass);\\n```","source":{"line":205,"path":"src/Core/Services/CustomClassService.lua"}}')}}]);